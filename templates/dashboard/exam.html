{% extends "dashboard/common/base.html" %}

{% block pagecontent %}

{% include "dashboard/courses-list.html" with course=exam.course %}

<div id="main" class="ui page">
	<input type="hidden" id="exam-id" value="{{ exam.id }}"/>
	<h1>{{ exam.name }}</h1>
	<div class="ui secondary segment question-list">
		<h1>LIST</h1>
		<h2 class="header">WHA</h2>
	</div>
</div>

<!-- data storage -->
<input id="backend-data-delivery" type="hidden" value="{{ question_set_json }}">

<!-- multichoice is special so it needs further templates for choices -->
<div class="multichoice-edit-option template" hidden>
	<div class="option-container">
		<input name="option" data-x="option" type="text"></input>
		<input name="answer" data-x="answer" type="radio"></input>
	</div>
</div>

<!-- multichoice -->
<div class="multichoice template" hidden>
	<!-- summary -->
	<div class="summary question-section">
		<h1 data-x="option-count"></h1>
		<!-- data-x tags indicate lowest level storage of question data -->
		<div>#<span data-x="number"></span></div>
		<div>Points:<span data-x="points"></span></div>
		<span data-x="prompt-substr"></span>
		<span data-x="type"></span>
	</div>

	<!-- edit -->
	<div class="edit question-section">
		
		<div>#<span data-x="number"></span></div>

		<span data-x="type">Multiple Choice</span>

		<label for="points">Points</label>
		<input name="points" data-x="points" type="text"/>	

		<label for="prompt">Prompt</label>
		<input name="prompt" data-x="prompt" type="text"></input>

		<div class="options">
		<!-- generated from template -->
		</div>

	</div>

	<!-- preview -->
	<div class="preview question-section" data-x="preview">
	<!--  pulls from the backend via ajax-->
	</div>
</div>

<!-- truefalse -->
<div class="truefalse template" hidden>
	<!-- summary -->
	<div class="summary question-section">

		<div>#<span data-x="number"></span></div>
		<div>Points:<span data-x="points"></span></div>

		<span data-x="type"></span>
		<span data-x="prompt-substr"></span>
	</div>

	<!-- edit -->
	<div class="edit question-section">

		<div>#<span data-x="number"></span></div>
		<div>Points:<span data-x="points"></span></div>

		<label for="prompt"></label>
		<input name="prompt" data-x="prompt">

		<label for="option">True/False</label>
		<input data-x="option" name="option" type="checkbox"/>
	</div>

	<!-- preview -->
	<div class="preview question-section">
		<!-- generated from the backend -->
	</div>
</div>

<!-- essay -->
<div class="essay template" hidden>
	<!-- summary -->
	<div class="summary question-section">
	<h1>summary</h1>
		<div>#<span data-x="number"></span></div>
		<div>Points:<span data-x="points"></span></div>

		<span data-x="type"></span>
		<span data-x="prompt-substr"></span>
	</div>

	<!-- edit -->
	<div class="edit question-section">
		<h1>edit</h1>
		<div>#<span data-x="number"></span></div>
		<div>Points:<span data-x="points"></span></div>

		<label for="prompt"></label>
		<input name="prompt" data-x="prompt" type="text">
	</div>

	<!-- preview -->
	<div class="preview question-section">
	<h1>preview</h1>
		<!-- generated from the backend -->
	</div>
</div>

<!-- shortanswer -->
<div class="shortanswer template" hidden>
	<!-- summary -->
	<div class="summary question-section">
		<h1>summary</h1>
		<div>#<span data-x="number"></span></div>
		<div>Points:<span data-x="points"></span></div>

		<span data-x="type"></span>
		<h1 data-x="prompt-substr"></h1>
	</div>

	<!-- edit -->
	<div class="edit question-section">
		<h1>edit</h1>
		<div>#<span data-x="number"></span></div>
		<div>Points:<span data-x="points"></span></div>

		<label for="prompt"></label>
		<input name="prompt" data-x="prompt" type="text">
	</div>

	<!-- preview -->
	<div class="preview question-section">
		<h1>preview</h1>
		<!-- generated from the backend -->
	</div>
</div>
<style type="text/css">
	div {
		border: 1px solid black !important;
	}
</style>
<script type="text/javascript">
	document.addEventListener("DOMContentLoaded", function() {
		const questions_present_at_pageload = JSON.parse($('#backend-data-delivery').val());
		const question_list_selector = '.question-list';
		const max_prompt_length_without_ellipses = 35;
		const use_ellipses_on_truncated_prompt = true;
		const exam_id = $('#exam-id').val();
		const api_endpoint_for_questions = '/api/question';
		const static_properties_of_questions = {
			"multichoice" : {
				template_selector : '.multichoice.template'
			},
			"shortanswer" : {
				template_selector : '.shortanswer.template'
			},
			"essay" : {
				template_selector : '.essay.template'
			}
		};
		/*
		question interface:
		{
		'question_id' : ''
		'type' : ''
		'prompt' : ''
		'points' : ''
		'number' : ''
		'answers' : []
		'options' : []
		}
		*/
		var templates = {}
		
		/* ------------ begin multichoice ------------- */
		const MultiQuestion = function() {
			const multichoice = this;
			multichoice.type = "multichoice";
			multichoice.manifestation = copy_template_and_create(multichoice.type);

			var my_data = multichoice._data = {
				'question_id' : '',
				'type' : 'multichoice',
				'prompt' : '',
				'points' : '',
				'number' : '',
				'options' : [],
				'answers' : []
				}

			/* selector : action so we can later do multichoice[action]() */
			const action_map = {
				'.submit' : 'submit',
				'.delete' : 'delete',
				'.add-choice' : 'add_choice',

			}

			const my_derived_sections = {
				'prompt' : ['prompt-substr']
			};

			/* prompt-substr is a projection, (read only) the others
			are pure data, meaning they are bound more generically */
			multichoice.prompt_substr = function() {
				if (arguments.length > 0) 
					console.log('argument ignored in .prompt_substr, which is read-only');
				
				const truncated_prompt = multichoice._data['prompt'].substr(0, max_prompt_length_without_ellipses);
				
				if (use_ellipses_on_truncated_prompt 
					&& truncated_prompt.length == max_prompt_length_without_ellipses) {

					return truncated_prompt + '...';
				}

				return truncated_prompt;
			}

			/* this function exposes all of the data for multichoice,
			-> for example question_id as a getter/setter <-
			setting it sets it internally and updates all of the places in the
			markup that are annotated data-x="question_id":
			some_multichoice_question.question_id(123)
			some_multichoice_question.question_id() <- 123 */
			var bind_property_to_multichoice_as_getter_setter = function(property) {
				multichoice[property] = function(value) {
					if (arguments.length > 0) {
						/* set */
						multichoice._data[property] = value;

						/* this block of code handles setting things like prompt-substr */
						if (my_derived_sections[property]) {
							for (var i in my_derived_sections[property]) {
								/* data-x attributes often have -'s in them, switch to _,
								  for example this lets us grab data-x="prompt-substr",
								  and populate it using our own getter, prompt_substr */
								var derived_property = my_derived_sections[property][i].replace(/-/gm, '_');
								multichoice.manifestation.find(
									'[data-x="'+my_derived_sections[property][i]+'"]'
									)
									.val(multichoice[derived_property]())
									.text(multichoice[derived_property]());
							}
						}
						var children = multichoice.manifestation.find('[data-x="'+property+'"]');
						children.val(value);
						children.text(value);
						return multichoice;
					} else {
						/* get */
						return multichoice._data[property]
					}
				}
			}

			/* expose all of the properties */
			for (var property_to_be_available in my_data) {
				if (is_type_of([], my_data[property_to_be_available])) continue;

				bind_property_to_multichoice_as_getter_setter(property_to_be_available);
			}

			multichoice.options = function() {
				return multichoice._data['options'];
			}

			multichoice.answers = function() {
				return multichoice._data['answers'];
			}

			const get_multichoice_option_index_in_options = function(multichoice_option) {
				var index = -1;
				multichoice.manifestation.find('.options .multichoice-edit-option').each(function(i,v){
					if ($(v).attr('data-member') === multichoice_option.attr('data-member')) {
						index = i;
					}
				})
				return index;
			}

			multichoice.option_count = function() {
				return multichoice._data['options'].length;	
			}

			var identifier_counter = 0;
			multichoice.add_choice = function(text, is_answer) {
				
				identifier_counter++;
				multichoice._data['options'].push(text);
				
				/*  update count */
				console.log('option count updated')
				multichoice.manifestation.find('[data-x="option-count"]').text(multichoice.option_count())
				multichoice.manifestation.find('[data-x="option-count"]').val(multichoice.option_count())

				new_edit_option = $('.multichoice-edit-option .template')
					.clone()
					.removeClass('.template')
					.show()
					.attr('data-member', identifier_counter);

				/* set text */
				new_edit_option.find('[data-x="option"]').val(text)
				
				if (is_answer && is_answer === true) {
					multichoice._data['answers'].push(text);
					new_edit_option.find('[data-x="answer"').prop('checked', true)
				} else {
					new_edit_option.find('[data-x="answer"').prop('checked', false)
				}

				/* add to dom */
				new_edit_option.appendTo(multichoice.manifestation.find('.options'));

				/* wirup delete for this guy */
				new_edit_option.find('.delete-option').on('click', function() {
					var index = get_multichoice_option_index_in_data(new_edit_option);
					multichoice._data['options'].splice(index);
					var answer_element = new_edit_option.find('[data-x="answer"]');
					if (answer_element.is(':checked')) {
						var answer_index = multichoice._data['answers'].indexOf(answer_element.val().trim());
						if (answer_index >= 0 && answer_index !== false) {
							multichoice._data['answers'].splice(answer_index);
						}
					}
					console.log(multichoice._data, 'removed one');

					new_edit_option.remove();

					/* update count */
					multichoice.manifestation.find('[data-x="option-count"]').text(multichoice.option_count());
					multichoice.manifestation.find('[data-x="option-count"]').val(multichoice.option_count());
				})

				/* onchange */
				new_edit_option.find('[data-x="answer"]').on('change', function() {
					multichoice._data['answers'] = [];
					multichoice.manifestation.find('[data-x="answer"]').each(function(i,v) {
						if ($(v).is(':checked')) 
							multichoice._data['answers'].push(
								$(v).closest('.option-container').find('[data-x="option"]').val().trim())
					});
				});

				/* only for teachers in the edit page really, normal dom elements don't change much */
				new_edit_option.find('[data-x="option"]').on('change', function() {
					multichoice._data['options'] = [];
					multichoice.manifestation.find('[data-x="option"]').each(function(i,v) {
						multichoice._data['options'].push($(v).val().trim());
					})
				});

				new_edit_option.find('.option');
			}

			multichoice.populate = function(data) {
				for (var property in multichoice._data) {
					if (is_type_of('', data[property]) || is_type_of(0, data[property])) {
						/* this passes the data at data['question_id'] to multichoice.question_id()
						to use the setter we have previously created. read the notes above on how
						the setter/getter works if this makes no sense */
						multichoice[property](data[property])
					}
				}
				console.log(data,"MULTICHOICE")
				/* the for loop only handles scalars, here we do the specifics */
				if (data['options']) {
					var has_answers = false;
					if (data['answers']) {
						var has_answers = true;
					}
					for (var i in data['options']) {
						var is_answer = false;
						if (has_answers) {
							var index = data['answers'].indexOf(data['options'][i].trim());
							if (index >= 0 && index !== false) {
								is_answer = true;
								/* don't add twice */
								data['answers'].splice(index);
							}
						}
						multichoice.add_choice(data['options'][i], is_answer);
					}
				}
			}

			multichoice.loading = function() {
				console.log('loading');
				/* TODO: pat, do your magic with spinners */
			}

			multichoice.done_loading = function() {
				console.log('done loading')
				/* TODO: pat, undo your magic with spinners */
			};

			var ajax_submit_complete = function(data, success, jqxhr) {
				/* this fires before always */
				if (success === "success" && data.success === true) {
					console.log('successfully saved question')
					multichoice.question_id(data.id);
					multichoice.done_loading();
				} else {
					console.log('server did not save the question!!!', data.message)
				}
			};
			var ajax_submit_failure = function() {
				/* this fires before always */
				console.log('failure to save question!')
			};
			var ajax_submit_always = function(data, success, jqxhr) {
				/* but this always fires =() */
				console.log('handler to be called no matter what when we submit <- just got called');
			};

			var ajax_delete_complete = function(data, success, jqxhr) {
				/* this fires before always */
				if (success === "success" && data.success === true) {
					console.log('successfully deleted!');
					multichoice.done_loading();
					multichoice.manifestation.remove();
				} else {
					console.log('the server did not delete our question!', data.message);
				}
			};
			var ajax_delete_failure = function() {
				/* this fires before always */
				console.log('failure to delete a question!', arguments);
			};
			var ajax_delete_always = function(data, success, jqxhr) {
				/* but this always fires =() */
				console.log('handler to be called no matter what when we delete <- just got called');
			};

			multichoice.submit = function(submit_custom_cb) {
				multichoice.loading();
				submit_question_data(multichoice._data, submit_custom_cb,
					 ajax_submit_complete,
					 ajax_submit_failure,
					 ajax_submit_always);
			};

			multichoice.delete = function(delete_custom_cb) {
				multichoice.loading();
				if (multichoice._data['question_id']) {
					delete_question(multichoice.question_id(), delete_custom_cb,
						ajax_delete_complete,
						ajax_delete_failure,
						ajax_delete_always);
				} else {
					/* mock ajax success for the handler */
					ajax_delete_complete({success: true}, "success"); 
				}
			};

			multichoice.preview = function() {
				/* SUGGESTION: put transition ui code here */
				multichoice.manifestation.find('.question-section').hide();
				multichoice.manifestation.find('.preview.question-section').show();
			};

			multichoice.edit = function() {
				/* SUGGESTION: put transition ui code here */
				multichoice.manifestation.find('.question-section').hide();
				multichoice.manifestation.find('.edit.question-section').show();
			};

			multichoice.summary = function() {
				/* SUGGESTION: put transition ui code here */
				multichoice.manifestation.find('.question-section').hide();
				multichoice.manifestation.find('.summary.question-section').show();
			}

			/* just for us */
			multichoice.manifestation.find('[data-x="option-count"]').text(multichoice.option_count()).val(multichoice.option_count());
			console.log('NEW MULTI', multichoice.option_count())

			/* last thing we do in construction is show ourselves */
			multichoice.manifestation.find('.question-section').hide()
			multichoice.manifestation.show();
			/* default mode is edit */
			multichoice.edit();
		}
		/* ------------ end multichoice ------------- */

		/* ------------ begin essay ------------- */
		const EssayQuestion = function() {
			const essay = this;
			essay.type = "essay";
			essay.manifestation = copy_template_and_create(essay.type);

			var my_data = essay._data = {
				'question_id' : '',
				'type' : 'essay',
				'prompt' : '',
				'points' : '',
				'number' : ''
				}

			const my_derived_sections = {
				'prompt' : ['prompt-substr']
			};
			/* prompt-substr is a projection, the others
			are pure data, meaning they are bound more generically */
			essay.prompt_substr = function() {
				if (arguments.length > 0) 
					console.log('argument ignored in .prompt_substr, which is read-only');
				
				const truncated_prompt = essay._data['prompt'].substr(0, max_prompt_length_without_ellipses);
				
				if (use_ellipses_on_truncated_prompt 
					&& truncated_prompt.length == max_prompt_length_without_ellipses) {

					return truncated_prompt + '...';
				}

				return truncated_prompt;
			}

			/* this function exposes all of the data for essay,
			-> for example question_id as a getter/setter <-
			setting it sets it internally and updates all of the places in the
			markup that are annotated data-x="question_id":
			some_essay_question.question_id(123)
			some_essay_question.question_id() <- 123 */
			var bind_property_to_essay_as_getter_setter = function(property) {
				essay[property] = function(value) {
					if (arguments.length > 0) {
						/* set */
						essay._data[property] = value;

						/* this block of code handles setting things like prompt-substr */
						if (my_derived_sections[property]) {
							for (var i in my_derived_sections[property]) {
								/* data-x attributes often have -'s in them, switch to _,
								  for example this lets us grab data-x="prompt-substr",
								  and populate it using our own getter, prompt_substr */
								var derived_property = my_derived_sections[property][i].replace(/-/gm, '_');
								essay.manifestation.find(
									'[data-x="'+my_derived_sections[property][i]+'"]'
									)
									.val(essay[derived_property]())
									.text(essay[derived_property]());
							}
						}
						var children = essay.manifestation.find('[data-x="'+property+'"]');
						children.val(value);
						children.text(value);
						return essay;
					} else {
						/* get */
						return essay._data[property]
					}
				}
			}

			/* expose all of the properties */
			for (var property_to_be_available in my_data) 
				bind_property_to_essay_as_getter_setter(property_to_be_available);	
			
			essay.populate = function(data) {
				for (var property in essay._data) {
					if (is_type_of('', data[property]) || is_type_of(0, data[property])) {
						/* this passes the data at data['question_id'] to essay.question_id()
						to use the setter we have previously created. read the notes above on how
						the setter/getter works if this makes no sense */
						essay[property](data[property])
					} else {
						console.log('incorrect value type encountered in population of essay:',property,data[property]);
					}
				}
			}

			essay.loading = function() {
				console.log('loading');
				/* TODO: pat, do your magic with spinners */
			}

			essay.done_loading = function() {
				console.log('done loading')
				/* TODO: pat, undo your magic with spinners */
			};

			var ajax_submit_complete = function(data, success, jqxhr) {
				/* this fires before always */
				if (success === "success" && data.success === true) {
					console.log('successfully saved question')
					essay.question_id(data.id);
					essay.done_loading();
				} else {
					console.log('server did not save the question!!!', data.message)
				}
			};
			var ajax_submit_failure = function() {
				/* this fires before always */
				console.log('failure to save question!')
			};
			var ajax_submit_always = function(data, success, jqxhr) {
				/* but this always fires =() */
				console.log('handler to be called no matter what when we submit <- just got called');
			};

			var ajax_delete_complete = function(data, success, jqxhr) {
				/* this fires before always */
				if (success === "success" && data.success === true) {
					console.log('successfully deleted!');
					essay.done_loading();
					essay.manifestation.remove();
				} else {
					console.log('the server did not delete our question!', data.message);
				}
			};
			var ajax_delete_failure = function() {
				/* this fires before always */
				console.log('failure to delete a question!', arguments);
			};
			var ajax_delete_always = function(data, success, jqxhr) {
				/* but this always fires =() */
				console.log('handler to be called no matter what when we delete <- just got called');
			};

			essay.submit = function(submit_custom_cb) {
				essay.loading();
				submit_question_data(essay._data, submit_custom_cb,
					 ajax_submit_complete,
					 ajax_submit_failure,
					 ajax_submit_always);
			};

			essay.delete = function(delete_custom_cb) {
				essay.loading();
				if (essay._data['question_id']) {
					delete_question(essay.question_id(), delete_custom_cb,
						ajax_delete_complete,
						ajax_delete_failure,
						ajax_delete_always);
				} else {
					/* mock ajax success for the handler */
					ajax_delete_complete({success: true}, "success"); 
				}
			};

			essay.preview = function() {
				/* SUGGESTION: put transition ui code here */
				essay.manifestation.find('.question-section').hide();
				essay.manifestation.find('.preview.question-section').show();
			};

			essay.edit = function() {
				/* SUGGESTION: put transition ui code here */
				essay.manifestation.find('.question-section').hide();
				essay.manifestation.find('.edit.question-section').show();
			};

			essay.summary = function() {
				/* SUGGESTION: put transition ui code here */
				essay.manifestation.find('.question-section').hide();
				essay.manifestation.find('.summary.question-section').show();
			}

			/* last thing we do in construction is show ourselves */
			essay.manifestation.show();
			/* default mode is edit */
			essay.edit();
		}
		/*---------------- end essay -------------*/


		/* ------------ begin short answer ------------- */
		const ShortAnswerQuestion = function() {
			const shortanswer = this;
			shortanswer.type = "shortanswer";
			shortanswer.manifestation = copy_template_and_create(shortanswer.type);

			var my_data = shortanswer._data = {
				'question_id' : '',
				'type' : 'shortanswer',
				'prompt' : '',
				'points' : '',
				'number' : ''
				}

			const my_derived_sections = {
				'prompt' : ['prompt-substr']
			};
			/* prompt-substr is a projection, the others
			are pure data, meaning they are bound more generically */
			shortanswer.prompt_substr = function() {
				if (arguments.length > 0) 
					console.log('argument ignored in .prompt_substr, which is read-only');
				
				const truncated_prompt = shortanswer._data['prompt'].substr(0, max_prompt_length_without_ellipses);
				
				if (use_ellipses_on_truncated_prompt 
					&& truncated_prompt.length == max_prompt_length_without_ellipses) {

					return truncated_prompt + '...';
				}

				return truncated_prompt;
			}

			/* this function exposes all of the data for shortanswer,
			-> for example question_id as a getter/setter <-
			setting it sets it internally and updates all of the places in the
			markup that are annotated data-x="question_id":
			some_shortanswer_question.question_id(123)
			some_shortanswer_question.question_id() <- 123 */
			var bind_property_to_shortanswer_as_getter_setter = function(property) {
				shortanswer[property] = function(value) {
					if (arguments.length > 0) {
						/* set */
						shortanswer._data[property] = value;

						/* this block of code handles setting things like prompt-substr */
						if (my_derived_sections[property]) {
							for (var i in my_derived_sections[property]) {
								/* data-x attributes often have -'s in them, switch to _,
								  for example this lets us grab data-x="prompt-substr",
								  and populate it using our own getter, prompt_substr */
								var derived_property = my_derived_sections[property][i].replace(/-/gm, '_');
								shortanswer.manifestation.find(
									'[data-x="'+my_derived_sections[property][i]+'"]'
									)
									.val(shortanswer[derived_property]())
									.text(shortanswer[derived_property]());
							}
						}
						var children = shortanswer.manifestation.find('[data-x="'+property+'"]');
						children.val(value);
						children.text(value);
						return shortanswer;
					} else {
						/* get */
						return shortanswer._data[property]
					}
				}
			}

			/* expose all of the properties */
			for (var property_to_be_available in my_data) 
				bind_property_to_shortanswer_as_getter_setter(property_to_be_available);	
			
			shortanswer.populate = function(data) {
				for (var property in shortanswer._data) {
					if (is_type_of('', data[property]) || is_type_of(0, data[property])) {
						/* this passes the data at data['question_id'] to shortanswer.question_id()
						to use the setter we have previously created. read the notes above on how
						the setter/getter works if this makes no sense */
						shortanswer[property](data[property])
					} else {
						console.log('incorrect type encountered in population of shortanswer:',property,data[property]);
					}
				}
			}

			shortanswer.loading = function() {
				console.log('loading');
				/* TODO: pat, do your magic with spinners */
			}

			shortanswer.done_loading = function() {
				console.log('done loading')
				/* TODO: pat, undo your magic with spinners */
			};

			var ajax_submit_complete = function(data, success, jqxhr) {
				/* this fires before always */
				if (success === "success" && data.success === true) {
					console.log('successfully saved question')
					shortanswer.question_id(data.id);
					shortanswer.done_loading();
				} else {
					console.log('server did not save the question!!!', data.message)
				}
			};
			var ajax_submit_failure = function() {
				/* this fires before always */
				console.log('failure to save question!')
			};
			var ajax_submit_always = function(data, success, jqxhr) {
				/* but this always fires =() */
				console.log('handler to be called no matter what when we submit <- just got called');
			};

			var ajax_delete_complete = function(data, success, jqxhr) {
				/* this fires before always */
				if (success === "success" && data.success === true) {
					console.log('successfully deleted!');
					shortanswer.done_loading();
					shortanswer.manifestation.remove();
				} else {
					console.log('the server did not delete our question!', data.message);
				}
			};
			var ajax_delete_failure = function() {
				/* this fires before always */
				console.log('failure to delete a question!', arguments);
			};
			var ajax_delete_always = function(data, success, jqxhr) {
				/* but this always fires =() */
				console.log('handler to be called no matter what when we delete <- just got called');
			};

			shortanswer.submit = function(submit_custom_cb) {
				shortanswer.loading();
				submit_question_data(shortanswer._data, submit_custom_cb,
					 ajax_submit_complete,
					 ajax_submit_failure,
					 ajax_submit_always);
			};

			shortanswer.delete = function(delete_custom_cb) {
				shortanswer.loading();
				if (shortanswer._data['question_id']) {
					delete_question(shortanswer.question_id(), delete_custom_cb,
						ajax_delete_complete,
						ajax_delete_failure,
						ajax_delete_always);
				} else {
					/* mock ajax success for the handler */
					ajax_delete_complete({success: true}, "success"); 
				}
			};

			shortanswer.preview = function() {
				/* SUGGESTION: put transition ui code here */
				shortanswer.manifestation.find('.question-section').hide();
				shortanswer.manifestation.find('.preview.question-section').show();
			};

			shortanswer.edit = function() {
				/* SUGGESTION: put transition ui code here */
				shortanswer.manifestation.find('.question-section').hide();
				shortanswer.manifestation.find('.edit.question-section').show();
			};

			shortanswer.summary = function() {
				/* SUGGESTION: put transition ui code here */
				shortanswer.manifestation.find('.question-section').hide();
				shortanswer.manifestation.find('.summary.question-section').show();
			}

			/* last thing we do in construction is show ourselves */
			shortanswer.manifestation.show();
			/* default mode is edit */
			shortanswer.edit();
		}
		/*---------------- end short answer -------------*/ 
		const TFQuestion = function() {
			this.type = "truefalse";
			this.manifestation = copy_template_and_create(this.type)

			this.state = 'none'
		}

		function is_type_of(example, thing_to_be_tested) {
			return typeof(example) === typeof(thing_to_be_tested);
		}

		function copy_template_and_create(type) {
			return $(static_properties_of_questions[type].template_selector)
				.clone()
				.removeClass('template')
				.appendTo(question_list_selector);
		}

		function get_type_class(type) {
			switch(type){
				case "multichoice" : return MultiQuestion
				case "shortanswer" : return ShortAnswerQuestion
				case "essay" : return EssayQuestion
				case "truefalse" : return TFQuestion
				default : throw("Unsupported question type!!!")
			}
		}
		function get_csrf_token() { return $.cookie('csrftoken'); }

		function submit_question_data(data, custom_completed, complete_callback, failure_callback, always_callback) {
			$.ajax({
					type : "POST",
					url : api_endpoint_for_questions,
					data :	{
						'question' : JSON.stringify(data),
						'exam_id' : exam_id
					},
					headers: {
						'X-CSRFToken' : get_csrf_token()
					}
				})
			.done(function(a, b, c, d) {
				complete_callback(a,b,c,d);
				!custom_completed || custom_completed(a,b,c,d); })
			.fail(failure_callback)
			.always(always_callback)
		}

		function fetch_preview_for(data, custom_completed, complete_callback, failure_callback, always_callback) {
			console.log("PREVIEW UNSUPPORTED R.N.")
		}

		function delete_question(question_id, custom_completed, complete_callback, failure_callback, always_callback) {
			if (!(is_type_of('',question_id) || is_type_of(0, question_id))){
				console.log('INVALID USAGE OF DELETE QUESTION: PASS AN ID, NOT AN OBJECT')
				return false;
			}
			$.ajax({
					type : "POST",
					url : api_endpoint_for_questions,
					data :	{
						'question_id' : question_id
					}, 
					headers :{
						'X-METHODOVERRIDE' : 'DELETE',
						'X-CSRFToken' : get_csrf_token()
					}
				})
			.done(function(a,b,c,d) {
				complete_callback(a,b,c,d);
				!custom_completed || custom_completed(a,b,c,d); })
			.fail(failure_callback)
			.always(always_callback)	
		}

		window.questions = [];
		for (var i in questions_present_at_pageload) {
			var question_data = questions_present_at_pageload[i];
			var question = null;
			switch(question_data.type){
				case "multichoice" :
					 question = new MultiQuestion();
					 break;
				case "shortanswer" :
				     question = new ShortAnswerQuestion();
				     break;
				case "essay" : 
					question = new EssayQuestion();
					break;
			}
			if (question === null) continue;
			question.populate(question_data);
			question.summary();
			questions.push(question)
		}

		var a = new MultiQuestion();
		window.a = a;
	});
</script>
{% endblock %}

{% block javascript %}

{% load static %}
<script src="{% static 'js/jquery.min.js'  %}"></script>
<script src="{% static 'js/jquery.cookie.js' %}"></script>
<script src="{% static 'js/add-course.js' %}"></script>
<script src="{% static 'js/new-exam.js' %}"></script>
<script src="{% static 'js/exam.js' %}"></script>
{% endblock %}
